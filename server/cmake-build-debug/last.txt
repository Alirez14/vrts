/* myserver.c */
#include <iostream>
#include <string>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sstream>
#include <sys/stat.h>
#include <dirent.h>
#include <fstream>
#include <string.h>
#define BUF 1024
#define PORT 6543
using namespace std;


void  ssend( char buffer[BUF], int  new_socket){


    send(new_socket, buffer, strlen(buffer),0);

}
string srec( int  new_socket){

    char buffer[BUF];

    stringstream ss;
    string s;
    ss<<recv (new_socket, buffer, BUF-1, 0);
    ss>>s;
    return s;
}
void Save(string sname , string message) {
    bool next = true;
    while (next == true) {
        string folder;

        static int emailnum = 1;
        string num;

        string Filename;
        ofstream File;
        string email = "Email";

        num = to_string(emailnum);

        Filename.append("/home/alirez/Desktop/VRTS/Mails/" + sname);

        folder = Filename;

        struct stat st;

        if (opendir(folder.c_str()) == NULL) {

            mkdir(folder.c_str(), 0777);
        } else {

            Filename = folder + "/" + email + num + ".txt";

            if (stat(Filename.c_str(), &st) == 0) {
                emailnum++;
                continue;

            } else {
                File.open(Filename);
                File << message;
                File.close();
                break;
            }
        }

    }
}
void Send(int sucket){
    string  sname , rname,subject;
    string message;
    string a;
    string buffer = "";
    char buf[BUF];
    strcpy(buf,buffer.c_str());
    send (sucket,"sender name max 8 char: \n" , strlen(buffer),0);
    sname = recv(sucket, buf, BUF-1, 0);
    strcpy(buf,buffer.c_str());

    send (sucket,"reciever name max 8 cahr: \n" , strlen(buffer),0);
    rname = recv(sucket, buf, BUF-1, 0);

    strcpy(buf,buffer.c_str());

    send (sucket,"subject name max 80 char: \n" , strlen(buffer),0);
    subject = recv(sucket, buf, BUF-1, 0);
    strcpy(buf,buffer.c_str());
    ssend("write message : \n" , sucket);

    while(a != "."){

        a = srec(sucket);
        message.append(a);
        message.append("\n");



    }
    string smessage=rname+subject+message;





}

int main (void) {
    int create_socket, new_socket;
    socklen_t addrlen;
    string buffer;
    int size;
    struct sockaddr_in address, cliaddress;


    create_socket = socket (AF_INET, SOCK_STREAM, 0);

    memset(&address,0,sizeof(address));
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons (PORT);

    if (bind ( create_socket, (struct sockaddr *) &address, sizeof (address)) != 0) {
        perror("bind error");
        return EXIT_FAILURE;
    }
    listen (create_socket, 5);

    addrlen = sizeof (struct sockaddr_in);

    while (1) {
        printf("Waiting for connections...\n");
        new_socket = accept ( create_socket, (struct sockaddr *) &cliaddress, &addrlen );
        if (new_socket > 0)
        {
            printf ("Client connected from %s:%d...\n", inet_ntoa (cliaddress.sin_addr),ntohs(cliaddress.sin_port));
            strcpy(buffer,"Welcome to myserver, Please enter your command:\n""choose the task: \n"
                                                                              "for send 1\n"
                                                                              "for list 2\n"
                                                                              "for read 3 \n"
                                                                              "for delete 4 \n"
                                                                              "for quit 0 \n");

            send(new_socket, buffer, strlen(buffer),0);

        }
        while (strncmp (buffer, "quit", 4)  != 0){
            size = recv (new_socket, buffer, BUF-1, 0);
            if( size > 0)
            {
                buffer[size] = '\0';
                printf ("Message received: %s\n", buffer);

                switch (buffer[0])
                {
                    case '1':
                        Send(new_socket);

                        continue;

                    case '2':
                        cout<< "g2\n";
                        continue;

                    case '3':
                        cout<< "g3\n";
                        continue;

                    case '4':
                        cout<< "g4\n";
                        continue;

                    case '0':
                        cout<< "g0\n";
                        buffer[0]='q';
                        buffer[1]='u';
                        buffer[2]='i';
                        buffer[3]='t';



                    default:
                        cout<< "error\n";

                        continue;


                }




            }


            else if (size == 0)
            {

                printf("Client closed remote socket\n");
                break;
            }
            else
            {
                perror("recv error");
                return EXIT_FAILURE;
            }
        }
        close (new_socket);
    }
    close (create_socket);
    return EXIT_SUCCESS;
}
